{"ast":null,"code":"import { __assign, __values, __spread, __read, __rest } from './_virtual/_tslib.js';\nimport { DEFAULT_GUARD_TYPE, STATE_DELIMITER } from './constants.js';\nimport { IS_PRODUCTION } from './environment.js';\nimport { mapValues, isArray, flatten, keys, toArray, toStateValue, isString, getEventType, matchesState, path, mapContext, toSCXMLEvent, pathToStateValue, isBuiltInEvent, partition, updateContext, warn, updateHistoryValue, toStatePath, mapFilterValues, toStatePaths, nestedPath, normalizeTarget, toGuard, toTransitionConfigArray, isMachine, isFunction } from './utils.js';\nimport { SpecialTargets } from './types.js';\nimport { getAllStateNodes, getConfiguration, has, getChildren, isInFinalState, getValue, isLeafNode } from './stateUtils.js';\nimport { start as start$1, stop as stop$1, pure, log, send, raise as raise$1, invoke, update, nullEvent, assign } from './actionTypes.js';\nimport { done, start, raise, stop, toActionObjects, toActionObject, resolveLog, resolveSend, resolveRaise, doneInvoke, error, toActivityDefinition, after, send as send$1, cancel, initEvent } from './actions.js';\nimport { State, stateValuesEqual } from './State.js';\nimport { createInvocableActor } from './Actor.js';\nvar NULL_EVENT = '';\nvar STATE_IDENTIFIER = '#';\nvar WILDCARD = '*';\nvar EMPTY_OBJECT = {};\n\nvar isStateId = function (str) {\n  return str[0] === STATE_IDENTIFIER;\n};\n\nvar createDefaultOptions = function () {\n  return {\n    actions: {},\n    guards: {},\n    services: {},\n    activities: {},\n    delays: {}\n  };\n};\n\nvar validateArrayifiedTransitions = function (stateNode, event, transitions) {\n  var hasNonLastUnguardedTarget = transitions.slice(0, -1).some(function (transition) {\n    return !('cond' in transition) && !('in' in transition) && (isString(transition.target) || isMachine(transition.target));\n  });\n  var eventText = event === NULL_EVENT ? 'the transient event' : \"event '\" + event + \"'\";\n  warn(!hasNonLastUnguardedTarget, \"One or more transitions for \" + eventText + \" on state '\" + stateNode.id + \"' are unreachable. \" + \"Make sure that the default transition is the last one defined.\");\n};\n\nvar StateNode =\n/*#__PURE__*/\n\n/** @class */\nfunction () {\n  function StateNode(\n  /**\r\n   * The raw config used to create the machine.\r\n   */\n  config, options,\n  /**\r\n   * The initial extended state\r\n   */\n  context) {\n    var _this = this;\n\n    this.config = config;\n    this.context = context;\n    /**\r\n     * The order this state node appears. Corresponds to the implicit SCXML document order.\r\n     */\n\n    this.order = -1;\n    this.__xstatenode = true;\n    this.__cache = {\n      events: undefined,\n      relativeValue: new Map(),\n      initialStateValue: undefined,\n      initialState: undefined,\n      on: undefined,\n      transitions: undefined,\n      candidates: {},\n      delayedTransitions: undefined\n    };\n    this.idMap = {};\n    this.options = Object.assign(createDefaultOptions(), options);\n    this.parent = this.options._parent;\n    this.key = this.config.key || this.options._key || this.config.id || '(machine)';\n    this.machine = this.parent ? this.parent.machine : this;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : STATE_DELIMITER);\n    this.id = this.config.id || __spread([this.machine.key], this.path).join(this.delimiter);\n    this.version = this.parent ? this.parent.version : this.config.version;\n    this.type = this.config.type || (this.config.parallel ? 'parallel' : this.config.states && keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n\n    if (!IS_PRODUCTION) {\n      warn(!('parallel' in this.config), \"The \\\"parallel\\\" property is deprecated and will be removed in version 4.1. \" + (this.config.parallel ? \"Replace with `type: 'parallel'`\" : \"Use `type: '\" + this.type + \"'`\") + \" in the config for state node '\" + this.id + \"' instead.\");\n    }\n\n    this.initial = this.config.initial;\n    this.states = this.config.states ? mapValues(this.config.states, function (stateConfig, key) {\n      var _a;\n\n      var stateNode = new StateNode(stateConfig, {\n        _parent: _this,\n        _key: key\n      });\n      Object.assign(_this.idMap, __assign((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));\n      return stateNode;\n    }) : EMPTY_OBJECT; // Document order\n\n    var order = 0;\n\n    function dfs(stateNode) {\n      var e_1, _a;\n\n      stateNode.order = order++;\n\n      try {\n        for (var _b = __values(getChildren(stateNode)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          dfs(child);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    dfs(this); // History config\n\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this._transient = !this.config.on ? false : Array.isArray(this.config.on) ? this.config.on.some(function (_a) {\n      var event = _a.event;\n      return event === NULL_EVENT;\n    }) : NULL_EVENT in this.config.on;\n    this.strict = !!this.config.strict; // TODO: deprecate (entry)\n\n    this.onEntry = toArray(this.config.entry || this.config.onEntry).map(function (action) {\n      return toActionObject(action);\n    }); // TODO: deprecate (exit)\n\n    this.onExit = toArray(this.config.exit || this.config.onExit).map(function (action) {\n      return toActionObject(action);\n    });\n    this.meta = this.config.meta;\n    this.data = this.type === 'final' ? this.config.data : undefined;\n    this.invoke = toArray(this.config.invoke).map(function (invokeConfig, i) {\n      var _a, _b;\n\n      if (isMachine(invokeConfig)) {\n        _this.machine.options.services = __assign((_a = {}, _a[invokeConfig.id] = invokeConfig, _a), _this.machine.options.services);\n        return {\n          type: invoke,\n          src: invokeConfig.id,\n          id: invokeConfig.id\n        };\n      } else if (typeof invokeConfig.src !== 'string') {\n        var invokeSrc = _this.id + \":invocation[\" + i + \"]\"; // TODO: util function\n\n        _this.machine.options.services = __assign((_b = {}, _b[invokeSrc] = invokeConfig.src, _b), _this.machine.options.services);\n        return __assign(__assign({\n          type: invoke,\n          id: invokeSrc\n        }, invokeConfig), {\n          src: invokeSrc\n        });\n      } else {\n        return __assign(__assign({}, invokeConfig), {\n          type: invoke,\n          id: invokeConfig.id || invokeConfig.src,\n          src: invokeConfig.src\n        });\n      }\n    });\n    this.activities = toArray(this.config.activities).concat(this.invoke).map(function (activity) {\n      return toActivityDefinition(activity);\n    });\n    this.transition = this.transition.bind(this);\n  }\n\n  StateNode.prototype._init = function () {\n    if (this.__cache.transitions) {\n      return;\n    }\n\n    getAllStateNodes(this).forEach(function (stateNode) {\n      return stateNode.on;\n    });\n  };\n  /**\r\n   * Clones this state machine with custom options and context.\r\n   *\r\n   * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.\r\n   * @param context Custom context (will override predefined context)\r\n   */\n\n\n  StateNode.prototype.withConfig = function (options, context) {\n    if (context === void 0) {\n      context = this.context;\n    }\n\n    var _a = this.options,\n        actions = _a.actions,\n        activities = _a.activities,\n        guards = _a.guards,\n        services = _a.services,\n        delays = _a.delays;\n    return new StateNode(this.config, {\n      actions: __assign(__assign({}, actions), options.actions),\n      activities: __assign(__assign({}, activities), options.activities),\n      guards: __assign(__assign({}, guards), options.guards),\n      services: __assign(__assign({}, services), options.services),\n      delays: __assign(__assign({}, delays), options.delays)\n    }, context);\n  };\n  /**\r\n   * Clones this state machine with custom context.\r\n   *\r\n   * @param context Custom context (will override predefined context, not recursive)\r\n   */\n\n\n  StateNode.prototype.withContext = function (context) {\n    return new StateNode(this.config, this.options, context);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"definition\", {\n    /**\r\n     * The well-structured state node definition.\r\n     */\n    get: function () {\n      return {\n        id: this.id,\n        key: this.key,\n        version: this.version,\n        type: this.type,\n        initial: this.initial,\n        history: this.history,\n        states: mapValues(this.states, function (state) {\n          return state.definition;\n        }),\n        on: this.on,\n        transitions: this.transitions,\n        onEntry: this.onEntry,\n        onExit: this.onExit,\n        activities: this.activities || [],\n        meta: this.meta,\n        order: this.order || -1,\n        data: this.data,\n        invoke: this.invoke\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateNode.prototype.toJSON = function () {\n    return this.definition;\n  };\n\n  Object.defineProperty(StateNode.prototype, \"on\", {\n    /**\r\n     * The mapping of events to transitions.\r\n     */\n    get: function () {\n      if (this.__cache.on) {\n        return this.__cache.on;\n      }\n\n      var transitions = this.transitions;\n      return this.__cache.on = transitions.reduce(function (map, transition) {\n        map[transition.eventType] = map[transition.eventType] || [];\n        map[transition.eventType].push(transition);\n        return map;\n      }, {});\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"after\", {\n    get: function () {\n      return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"transitions\", {\n    /**\r\n     * All the transitions that can be taken from this state node.\r\n     */\n    get: function () {\n      return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateNode.prototype.getCandidates = function (eventName) {\n    if (this.__cache.candidates[eventName]) {\n      return this.__cache.candidates[eventName];\n    }\n\n    var transient = eventName === NULL_EVENT;\n    var candidates = this.transitions.filter(function (transition) {\n      var sameEventType = transition.eventType === eventName; // null events should only match against eventless transitions\n\n      return transient ? sameEventType : sameEventType || transition.eventType === WILDCARD;\n    });\n    this.__cache.candidates[eventName] = candidates;\n    return candidates;\n  };\n  /**\r\n   * All delayed transitions from the config.\r\n   */\n\n\n  StateNode.prototype.getDelayedTransitions = function () {\n    var _this = this;\n\n    var afterConfig = this.config.after;\n\n    if (!afterConfig) {\n      return [];\n    }\n\n    var mutateEntryExit = function (delay, i) {\n      var delayRef = isFunction(delay) ? _this.id + \":delay[\" + i + \"]\" : delay;\n      var eventType = after(delayRef, _this.id);\n\n      _this.onEntry.push(send$1(eventType, {\n        delay: delay\n      }));\n\n      _this.onExit.push(cancel(eventType));\n\n      return eventType;\n    };\n\n    var delayedTransitions = isArray(afterConfig) ? afterConfig.map(function (transition, i) {\n      var eventType = mutateEntryExit(transition.delay, i);\n      return __assign(__assign({}, transition), {\n        event: eventType\n      });\n    }) : flatten(keys(afterConfig).map(function (delay, i) {\n      var configTransition = afterConfig[delay];\n      var resolvedTransition = isString(configTransition) ? {\n        target: configTransition\n      } : configTransition;\n      var resolvedDelay = !isNaN(+delay) ? +delay : delay;\n      var eventType = mutateEntryExit(resolvedDelay, i);\n      return toArray(resolvedTransition).map(function (transition) {\n        return __assign(__assign({}, transition), {\n          event: eventType,\n          delay: resolvedDelay\n        });\n      });\n    }));\n    return delayedTransitions.map(function (delayedTransition) {\n      var delay = delayedTransition.delay;\n      return __assign(__assign({}, _this.formatTransition(delayedTransition)), {\n        delay: delay\n      });\n    });\n  };\n  /**\r\n   * Returns the state nodes represented by the current state value.\r\n   *\r\n   * @param state The state value or State instance\r\n   */\n\n\n  StateNode.prototype.getStateNodes = function (state) {\n    var _a;\n\n    var _this = this;\n\n    if (!state) {\n      return [];\n    }\n\n    var stateValue = state instanceof State ? state.value : toStateValue(state, this.delimiter);\n\n    if (isString(stateValue)) {\n      var initialStateValue = this.getStateNode(stateValue).initial;\n      return initialStateValue !== undefined ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a)) : [this.states[stateValue]];\n    }\n\n    var subStateKeys = keys(stateValue);\n    var subStateNodes = subStateKeys.map(function (subStateKey) {\n      return _this.getStateNode(subStateKey);\n    });\n    return subStateNodes.concat(subStateKeys.reduce(function (allSubStateNodes, subStateKey) {\n      var subStateNode = _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);\n\n      return allSubStateNodes.concat(subStateNode);\n    }, []));\n  };\n  /**\r\n   * Returns `true` if this state node explicitly handles the given event.\r\n   *\r\n   * @param event The event in question\r\n   */\n\n\n  StateNode.prototype.handles = function (event) {\n    var eventType = getEventType(event);\n    return this.events.includes(eventType);\n  };\n  /**\r\n   * Resolves the given `state` to a new `State` instance relative to this machine.\r\n   *\r\n   * This ensures that `.events` and `.nextEvents` represent the correct values.\r\n   *\r\n   * @param state The state to resolve\r\n   */\n\n\n  StateNode.prototype.resolveState = function (state) {\n    var configuration = Array.from(getConfiguration([], this.getStateNodes(state.value)));\n    return new State(__assign(__assign({}, state), {\n      value: this.resolve(state.value),\n      configuration: configuration\n    }));\n  };\n\n  StateNode.prototype.transitionLeafNode = function (stateValue, state, _event) {\n    var stateNode = this.getStateNode(stateValue);\n    var next = stateNode.next(state, _event);\n\n    if (!next || !next.transitions.length) {\n      return this.next(state, _event);\n    }\n\n    return next;\n  };\n\n  StateNode.prototype.transitionCompoundNode = function (stateValue, state, _event) {\n    var subStateKeys = keys(stateValue);\n    var stateNode = this.getStateNode(subStateKeys[0]);\n\n    var next = stateNode._transition(stateValue[subStateKeys[0]], state, _event);\n\n    if (!next || !next.transitions.length) {\n      return this.next(state, _event);\n    }\n\n    return next;\n  };\n\n  StateNode.prototype.transitionParallelNode = function (stateValue, state, _event) {\n    var e_2, _a;\n\n    var transitionMap = {};\n\n    try {\n      for (var _b = __values(keys(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var subStateKey = _c.value;\n        var subStateValue = stateValue[subStateKey];\n\n        if (!subStateValue) {\n          continue;\n        }\n\n        var subStateNode = this.getStateNode(subStateKey);\n\n        var next = subStateNode._transition(subStateValue, state, _event);\n\n        if (next) {\n          transitionMap[subStateKey] = next;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    var stateTransitions = keys(transitionMap).map(function (key) {\n      return transitionMap[key];\n    });\n    var enabledTransitions = flatten(stateTransitions.map(function (st) {\n      return st.transitions;\n    }));\n    var willTransition = stateTransitions.some(function (st) {\n      return st.transitions.length > 0;\n    });\n\n    if (!willTransition) {\n      return this.next(state, _event);\n    }\n\n    var entryNodes = flatten(stateTransitions.map(function (t) {\n      return t.entrySet;\n    }));\n    var configuration = flatten(keys(transitionMap).map(function (key) {\n      return transitionMap[key].configuration;\n    }));\n    return {\n      transitions: enabledTransitions,\n      entrySet: entryNodes,\n      exitSet: flatten(stateTransitions.map(function (t) {\n        return t.exitSet;\n      })),\n      configuration: configuration,\n      source: state,\n      actions: flatten(keys(transitionMap).map(function (key) {\n        return transitionMap[key].actions;\n      }))\n    };\n  };\n\n  StateNode.prototype._transition = function (stateValue, state, _event) {\n    // leaf node\n    if (isString(stateValue)) {\n      return this.transitionLeafNode(stateValue, state, _event);\n    } // hierarchical node\n\n\n    if (keys(stateValue).length === 1) {\n      return this.transitionCompoundNode(stateValue, state, _event);\n    } // orthogonal node\n\n\n    return this.transitionParallelNode(stateValue, state, _event);\n  };\n\n  StateNode.prototype.next = function (state, _event) {\n    var e_3, _a;\n\n    var _this = this;\n\n    var eventName = _event.name;\n    var actions = [];\n    var nextStateNodes = [];\n    var selectedTransition;\n\n    try {\n      for (var _b = __values(this.getCandidates(eventName)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var candidate = _c.value;\n        var cond = candidate.cond,\n            stateIn = candidate.in;\n        var resolvedContext = state.context;\n        var isInState = stateIn ? isString(stateIn) && isStateId(stateIn) ? // Check if in state by ID\n        state.matches(toStateValue(this.getStateNodeById(stateIn).path, this.delimiter)) : // Check if in state by relative grandparent\n        matchesState(toStateValue(stateIn, this.delimiter), path(this.path.slice(0, -2))(state.value)) : true;\n        var guardPassed = false;\n\n        try {\n          guardPassed = !cond || this.evaluateGuard(cond, resolvedContext, _event, state);\n        } catch (err) {\n          throw new Error(\"Unable to evaluate guard '\" + (cond.name || cond.type) + \"' in transition for event '\" + eventName + \"' in state node '\" + this.id + \"':\\n\" + err.message);\n        }\n\n        if (guardPassed && isInState) {\n          if (candidate.target !== undefined) {\n            nextStateNodes = candidate.target;\n          }\n\n          actions.push.apply(actions, __spread(candidate.actions));\n          selectedTransition = candidate;\n          break;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    if (!selectedTransition) {\n      return undefined;\n    }\n\n    if (!nextStateNodes.length) {\n      return {\n        transitions: [selectedTransition],\n        entrySet: [],\n        exitSet: [],\n        configuration: state.value ? [this] : [],\n        source: state,\n        actions: actions\n      };\n    }\n\n    var allNextStateNodes = flatten(nextStateNodes.map(function (stateNode) {\n      return _this.getRelativeStateNodes(stateNode, state.historyValue);\n    }));\n    var isInternal = !!selectedTransition.internal;\n    var reentryNodes = isInternal ? [] : flatten(allNextStateNodes.map(function (n) {\n      return _this.nodesFromChild(n);\n    }));\n    return {\n      transitions: [selectedTransition],\n      entrySet: reentryNodes,\n      exitSet: isInternal ? [] : [this],\n      configuration: allNextStateNodes,\n      source: state,\n      actions: actions\n    };\n  };\n\n  StateNode.prototype.nodesFromChild = function (childStateNode) {\n    if (childStateNode.escapes(this)) {\n      return [];\n    }\n\n    var nodes = [];\n    var marker = childStateNode;\n\n    while (marker && marker !== this) {\n      nodes.push(marker);\n      marker = marker.parent;\n    }\n\n    nodes.push(this); // inclusive\n\n    return nodes;\n  };\n  /**\r\n   * Whether the given state node \"escapes\" this state node. If the `stateNode` is equal to or the parent of\r\n   * this state node, it does not escape.\r\n   */\n\n\n  StateNode.prototype.escapes = function (stateNode) {\n    if (this === stateNode) {\n      return false;\n    }\n\n    var parent = this.parent;\n\n    while (parent) {\n      if (parent === stateNode) {\n        return false;\n      }\n\n      parent = parent.parent;\n    }\n\n    return true;\n  };\n\n  StateNode.prototype.evaluateGuard = function (guard, context, _event, state) {\n    var guards = this.machine.options.guards;\n    var guardMeta = {\n      state: state,\n      cond: guard,\n      _event: _event\n    }; // TODO: do not hardcode!\n\n    if (guard.type === DEFAULT_GUARD_TYPE) {\n      return guard.predicate(context, _event.data, guardMeta);\n    }\n\n    var condFn = guards[guard.type];\n\n    if (!condFn) {\n      throw new Error(\"Guard '\" + guard.type + \"' is not implemented on machine '\" + this.machine.id + \"'.\");\n    }\n\n    return condFn(context, _event.data, guardMeta);\n  };\n\n  StateNode.prototype.getActions = function (transition, currentContext, _event, prevState) {\n    var e_4, _a, e_5, _b;\n\n    var prevConfig = getConfiguration([], prevState ? this.getStateNodes(prevState.value) : [this]);\n    var resolvedConfig = transition.configuration.length ? getConfiguration(prevConfig, transition.configuration) : prevConfig;\n\n    try {\n      for (var resolvedConfig_1 = __values(resolvedConfig), resolvedConfig_1_1 = resolvedConfig_1.next(); !resolvedConfig_1_1.done; resolvedConfig_1_1 = resolvedConfig_1.next()) {\n        var sn = resolvedConfig_1_1.value;\n\n        if (!has(prevConfig, sn)) {\n          transition.entrySet.push(sn);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (resolvedConfig_1_1 && !resolvedConfig_1_1.done && (_a = resolvedConfig_1.return)) _a.call(resolvedConfig_1);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    try {\n      for (var prevConfig_1 = __values(prevConfig), prevConfig_1_1 = prevConfig_1.next(); !prevConfig_1_1.done; prevConfig_1_1 = prevConfig_1.next()) {\n        var sn = prevConfig_1_1.value;\n\n        if (!has(resolvedConfig, sn) || has(transition.exitSet, sn.parent)) {\n          transition.exitSet.push(sn);\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (prevConfig_1_1 && !prevConfig_1_1.done && (_b = prevConfig_1.return)) _b.call(prevConfig_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    if (!transition.source) {\n      transition.exitSet = []; // Ensure that root StateNode (machine) is entered\n\n      transition.entrySet.push(this);\n    }\n\n    var doneEvents = flatten(transition.entrySet.map(function (sn) {\n      var events = [];\n\n      if (sn.type !== 'final') {\n        return events;\n      }\n\n      var parent = sn.parent;\n      events.push(done(sn.id, sn.data), // TODO: deprecate - final states should not emit done events for their own state.\n      done(parent.id, sn.data ? mapContext(sn.data, currentContext, _event) : undefined));\n\n      if (parent.parent) {\n        var grandparent = parent.parent;\n\n        if (grandparent.type === 'parallel') {\n          if (getChildren(grandparent).every(function (parentNode) {\n            return isInFinalState(transition.configuration, parentNode);\n          })) {\n            events.push(done(grandparent.id, grandparent.data));\n          }\n        }\n      }\n\n      return events;\n    }));\n    transition.exitSet.sort(function (a, b) {\n      return b.order - a.order;\n    });\n    transition.entrySet.sort(function (a, b) {\n      return a.order - b.order;\n    });\n    var entryStates = new Set(transition.entrySet);\n    var exitStates = new Set(transition.exitSet);\n\n    var _c = __read([flatten(Array.from(entryStates).map(function (stateNode) {\n      return __spread(stateNode.activities.map(function (activity) {\n        return start(activity);\n      }), stateNode.onEntry);\n    })).concat(doneEvents.map(raise)), flatten(Array.from(exitStates).map(function (stateNode) {\n      return __spread(stateNode.onExit, stateNode.activities.map(function (activity) {\n        return stop(activity);\n      }));\n    }))], 2),\n        entryActions = _c[0],\n        exitActions = _c[1];\n\n    var actions = toActionObjects(exitActions.concat(transition.actions).concat(entryActions), this.machine.options.actions);\n    return actions;\n  };\n  /**\r\n   * Determines the next state given the current `state` and sent `event`.\r\n   *\r\n   * @param state The current State instance or state value\r\n   * @param event The event that was sent at the current state\r\n   * @param context The current context (extended state) of the current state\r\n   */\n\n\n  StateNode.prototype.transition = function (state, event, context) {\n    if (state === void 0) {\n      state = this.initialState;\n    }\n\n    var _event = toSCXMLEvent(event);\n\n    var currentState;\n\n    if (state instanceof State) {\n      currentState = context === undefined ? state : this.resolveState(State.from(state, context));\n    } else {\n      var resolvedStateValue = isString(state) ? this.resolve(pathToStateValue(this.getResolvedPath(state))) : this.resolve(state);\n      var resolvedContext = context ? context : this.machine.context;\n      currentState = this.resolveState(State.from(resolvedStateValue, resolvedContext));\n    }\n\n    if (!IS_PRODUCTION && _event.name === WILDCARD) {\n      throw new Error(\"An event cannot have the wildcard type ('\" + WILDCARD + \"')\");\n    }\n\n    if (this.strict) {\n      if (!this.events.includes(_event.name) && !isBuiltInEvent(_event.name)) {\n        throw new Error(\"Machine '\" + this.id + \"' does not accept event '\" + _event.name + \"'\");\n      }\n    }\n\n    var stateTransition = this._transition(currentState.value, currentState, _event) || {\n      transitions: [],\n      configuration: [],\n      entrySet: [],\n      exitSet: [],\n      source: currentState,\n      actions: []\n    };\n    var prevConfig = getConfiguration([], this.getStateNodes(currentState.value));\n    var resolvedConfig = stateTransition.configuration.length ? getConfiguration(prevConfig, stateTransition.configuration) : prevConfig;\n    stateTransition.configuration = __spread(resolvedConfig);\n    return this.resolveTransition(stateTransition, currentState, _event);\n  };\n\n  StateNode.prototype.resolveRaisedTransition = function (state, _event, originalEvent) {\n    var _a;\n\n    var currentActions = state.actions;\n    state = this.transition(state, _event); // Save original event to state\n\n    state._event = originalEvent;\n    state.event = originalEvent.data;\n\n    (_a = state.actions).unshift.apply(_a, __spread(currentActions));\n\n    return state;\n  };\n\n  StateNode.prototype.resolveTransition = function (stateTransition, currentState, _event, context) {\n    var e_6, _a;\n\n    var _this = this;\n\n    if (_event === void 0) {\n      _event = initEvent;\n    }\n\n    if (context === void 0) {\n      context = this.machine.context;\n    }\n\n    var configuration = stateTransition.configuration; // Transition will \"apply\" if:\n    // - this is the initial state (there is no current state)\n    // - OR there are transitions\n\n    var willTransition = !currentState || stateTransition.transitions.length > 0;\n    var resolvedStateValue = willTransition ? getValue(this.machine, configuration) : undefined;\n    var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : undefined : undefined;\n    var currentContext = currentState ? currentState.context : context;\n    var actions = this.getActions(stateTransition, currentContext, _event, currentState);\n    var activities = currentState ? __assign({}, currentState.activities) : {};\n\n    try {\n      for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {\n        var action = actions_1_1.value;\n\n        if (action.type === start$1) {\n          activities[action.activity.type] = action;\n        } else if (action.type === stop$1) {\n          activities[action.activity.type] = false;\n        }\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    var _b = __read(partition(actions, function (action) {\n      return action.type === assign;\n    }), 2),\n        assignActions = _b[0],\n        otherActions = _b[1];\n\n    var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n    var resolvedActions = flatten(otherActions.map(function (actionObject) {\n      switch (actionObject.type) {\n        case raise$1:\n          return resolveRaise(actionObject);\n\n        case send:\n          var sendAction = resolveSend(actionObject, updatedContext, _event, _this.machine.options.delays); // TODO: fix ActionTypes.Init\n\n          if (!IS_PRODUCTION) {\n            // warn after resolving as we can create better contextual message here\n            warn(!isString(actionObject.delay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length\n            \"No delay reference for delay expression '\" + actionObject.delay + \"' was found on machine '\" + _this.machine.id + \"'\");\n          }\n\n          return sendAction;\n\n        case log:\n          return resolveLog(actionObject, updatedContext, _event);\n\n        case pure:\n          return actionObject.get(updatedContext, _event.data) || [];\n\n        default:\n          return toActionObject(actionObject, _this.options.actions);\n      }\n    }));\n\n    var _c = __read(partition(resolvedActions, function (action) {\n      return action.type === raise$1 || action.type === send && action.to === SpecialTargets.Internal;\n    }), 2),\n        raisedEvents = _c[0],\n        nonRaisedActions = _c[1];\n\n    var invokeActions = resolvedActions.filter(function (action) {\n      return action.type === start$1 && action.activity.type === invoke;\n    });\n    var children = invokeActions.reduce(function (acc, action) {\n      acc[action.activity.id] = createInvocableActor(action.activity);\n      return acc;\n    }, currentState ? __assign({}, currentState.children) : {});\n    var resolvedConfiguration = resolvedStateValue ? stateTransition.configuration : currentState ? currentState.configuration : [];\n    var meta = resolvedConfiguration.reduce(function (acc, stateNode) {\n      if (stateNode.meta !== undefined) {\n        acc[stateNode.id] = stateNode.meta;\n      }\n\n      return acc;\n    }, {});\n    var isDone = isInFinalState(resolvedConfiguration, this);\n    var nextState = new State({\n      value: resolvedStateValue || currentState.value,\n      context: updatedContext,\n      _event: _event,\n      // Persist _sessionid between states\n      _sessionid: currentState ? currentState._sessionid : null,\n      historyValue: resolvedStateValue ? historyValue ? updateHistoryValue(historyValue, resolvedStateValue) : undefined : currentState ? currentState.historyValue : undefined,\n      history: !resolvedStateValue || stateTransition.source ? currentState : undefined,\n      actions: resolvedStateValue ? nonRaisedActions : [],\n      activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},\n      meta: resolvedStateValue ? meta : currentState ? currentState.meta : undefined,\n      events: [],\n      configuration: resolvedConfiguration,\n      transitions: stateTransition.transitions,\n      children: children,\n      done: isDone\n    });\n    nextState.changed = _event.name === update || !!assignActions.length; // Dispose of penultimate histories to prevent memory leaks\n\n    var history = nextState.history;\n\n    if (history) {\n      delete history.history;\n    }\n\n    if (!resolvedStateValue) {\n      return nextState;\n    }\n\n    var maybeNextState = nextState;\n\n    if (!isDone) {\n      var isTransient = this._transient || configuration.some(function (stateNode) {\n        return stateNode._transient;\n      });\n\n      if (isTransient) {\n        maybeNextState = this.resolveRaisedTransition(maybeNextState, {\n          type: nullEvent\n        }, _event);\n      }\n\n      while (raisedEvents.length) {\n        var raisedEvent = raisedEvents.shift();\n        maybeNextState = this.resolveRaisedTransition(maybeNextState, raisedEvent._event, _event);\n      }\n    } // Detect if state changed\n\n\n    var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || !!assignActions.length || typeof history.value !== typeof maybeNextState.value || !stateValuesEqual(maybeNextState.value, history.value) : undefined);\n    maybeNextState.changed = changed; // Preserve original history after raised events\n\n    maybeNextState.historyValue = nextState.historyValue;\n    maybeNextState.history = history;\n    return maybeNextState;\n  };\n  /**\r\n   * Returns the child state node from its relative `stateKey`, or throws.\r\n   */\n\n\n  StateNode.prototype.getStateNode = function (stateKey) {\n    if (isStateId(stateKey)) {\n      return this.machine.getStateNodeById(stateKey);\n    }\n\n    if (!this.states) {\n      throw new Error(\"Unable to retrieve child state '\" + stateKey + \"' from '\" + this.id + \"'; no child states exist.\");\n    }\n\n    var result = this.states[stateKey];\n\n    if (!result) {\n      throw new Error(\"Child state '\" + stateKey + \"' does not exist on '\" + this.id + \"'\");\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns the state node with the given `stateId`, or throws.\r\n   *\r\n   * @param stateId The state ID. The prefix \"#\" is removed.\r\n   */\n\n\n  StateNode.prototype.getStateNodeById = function (stateId) {\n    var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;\n\n    if (resolvedStateId === this.id) {\n      return this;\n    }\n\n    var stateNode = this.machine.idMap[resolvedStateId];\n\n    if (!stateNode) {\n      throw new Error(\"Child state node '#\" + resolvedStateId + \"' does not exist on machine '\" + this.id + \"'\");\n    }\n\n    return stateNode;\n  };\n  /**\r\n   * Returns the relative state node from the given `statePath`, or throws.\r\n   *\r\n   * @param statePath The string or string array relative path to the state node.\r\n   */\n\n\n  StateNode.prototype.getStateNodeByPath = function (statePath) {\n    if (typeof statePath === 'string' && isStateId(statePath)) {\n      try {\n        return this.getStateNodeById(statePath.slice(1));\n      } catch (e) {// try individual paths\n        // throw e;\n      }\n    }\n\n    var arrayStatePath = toStatePath(statePath, this.delimiter).slice();\n    var currentStateNode = this;\n\n    while (arrayStatePath.length) {\n      var key = arrayStatePath.shift();\n\n      if (!key.length) {\n        break;\n      }\n\n      currentStateNode = currentStateNode.getStateNode(key);\n    }\n\n    return currentStateNode;\n  };\n  /**\r\n   * Resolves a partial state value with its full representation in this machine.\r\n   *\r\n   * @param stateValue The partial state value to resolve.\r\n   */\n\n\n  StateNode.prototype.resolve = function (stateValue) {\n    var _a;\n\n    var _this = this;\n\n    if (!stateValue) {\n      return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties\n    }\n\n    switch (this.type) {\n      case 'parallel':\n        return mapValues(this.initialStateValue, function (subStateValue, subStateKey) {\n          return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;\n        });\n\n      case 'compound':\n        if (isString(stateValue)) {\n          var subStateNode = this.getStateNode(stateValue);\n\n          if (subStateNode.type === 'parallel' || subStateNode.type === 'compound') {\n            return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;\n          }\n\n          return stateValue;\n        }\n\n        if (!keys(stateValue).length) {\n          return this.initialStateValue || {};\n        }\n\n        return mapValues(stateValue, function (subStateValue, subStateKey) {\n          return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;\n        });\n\n      default:\n        return stateValue || EMPTY_OBJECT;\n    }\n  };\n\n  StateNode.prototype.getResolvedPath = function (stateIdentifier) {\n    if (isStateId(stateIdentifier)) {\n      var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];\n\n      if (!stateNode) {\n        throw new Error(\"Unable to find state node '\" + stateIdentifier + \"'\");\n      }\n\n      return stateNode.path;\n    }\n\n    return toStatePath(stateIdentifier, this.delimiter);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialStateValue\", {\n    get: function () {\n      var _a;\n\n      if (this.__cache.initialStateValue) {\n        return this.__cache.initialStateValue;\n      }\n\n      var initialStateValue;\n\n      if (this.type === 'parallel') {\n        initialStateValue = mapFilterValues(this.states, function (state) {\n          return state.initialStateValue || EMPTY_OBJECT;\n        }, function (stateNode) {\n          return !(stateNode.type === 'history');\n        });\n      } else if (this.initial !== undefined) {\n        if (!this.states[this.initial]) {\n          throw new Error(\"Initial state '\" + this.initial + \"' not found on '\" + this.key + \"'\");\n        }\n\n        initialStateValue = isLeafNode(this.states[this.initial]) ? this.initial : (_a = {}, _a[this.initial] = this.states[this.initial].initialStateValue, _a);\n      }\n\n      this.__cache.initialStateValue = initialStateValue;\n      return this.__cache.initialStateValue;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateNode.prototype.getInitialState = function (stateValue, context) {\n    var configuration = this.getStateNodes(stateValue);\n    return this.resolveTransition({\n      configuration: configuration,\n      entrySet: configuration,\n      exitSet: [],\n      transitions: [],\n      source: undefined,\n      actions: []\n    }, undefined, undefined, context);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialState\", {\n    /**\r\n     * The initial State instance, which includes all actions to be executed from\r\n     * entering the initial state.\r\n     */\n    get: function () {\n      this._init();\n\n      var initialStateValue = this.initialStateValue;\n\n      if (!initialStateValue) {\n        throw new Error(\"Cannot retrieve initial state from simple state '\" + this.id + \"'.\");\n      }\n\n      return this.getInitialState(initialStateValue);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"target\", {\n    /**\r\n     * The target state value of the history state node, if it exists. This represents the\r\n     * default state value to transition to if no history value exists yet.\r\n     */\n    get: function () {\n      var target;\n\n      if (this.type === 'history') {\n        var historyConfig = this.config;\n\n        if (isString(historyConfig.target)) {\n          target = isStateId(historyConfig.target) ? pathToStateValue(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;\n        } else {\n          target = historyConfig.target;\n        }\n      }\n\n      return target;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns the leaf nodes from a state path relative to this state node.\r\n   *\r\n   * @param relativeStateId The relative state path to retrieve the state nodes\r\n   * @param history The previous state to retrieve history\r\n   * @param resolve Whether state nodes should resolve to initial child state nodes\r\n   */\n\n  StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {\n    if (resolve === void 0) {\n      resolve = true;\n    }\n\n    return resolve ? relativeStateId.type === 'history' ? relativeStateId.resolveHistory(historyValue) : relativeStateId.initialStateNodes : [relativeStateId];\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialStateNodes\", {\n    get: function () {\n      var _this = this;\n\n      if (isLeafNode(this)) {\n        return [this];\n      } // Case when state node is compound but no initial state is defined\n\n\n      if (this.type === 'compound' && !this.initial) {\n        if (!IS_PRODUCTION) {\n          warn(false, \"Compound state node '\" + this.id + \"' has no initial state.\");\n        }\n\n        return [this];\n      }\n\n      var initialStateNodePaths = toStatePaths(this.initialStateValue);\n      return flatten(initialStateNodePaths.map(function (initialPath) {\n        return _this.getFromRelativePath(initialPath);\n      }));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Retrieves state nodes from a relative path to this state node.\r\n   *\r\n   * @param relativePath The relative path from this state node\r\n   * @param historyValue\r\n   */\n\n  StateNode.prototype.getFromRelativePath = function (relativePath) {\n    if (!relativePath.length) {\n      return [this];\n    }\n\n    var _a = __read(relativePath),\n        stateKey = _a[0],\n        childStatePath = _a.slice(1);\n\n    if (!this.states) {\n      throw new Error(\"Cannot retrieve subPath '\" + stateKey + \"' from node with no states\");\n    }\n\n    var childStateNode = this.getStateNode(stateKey);\n\n    if (childStateNode.type === 'history') {\n      return childStateNode.resolveHistory();\n    }\n\n    if (!this.states[stateKey]) {\n      throw new Error(\"Child state '\" + stateKey + \"' does not exist on '\" + this.id + \"'\");\n    }\n\n    return this.states[stateKey].getFromRelativePath(childStatePath);\n  };\n\n  StateNode.prototype.historyValue = function (relativeStateValue) {\n    if (!keys(this.states).length) {\n      return undefined;\n    }\n\n    return {\n      current: relativeStateValue || this.initialStateValue,\n      states: mapFilterValues(this.states, function (stateNode, key) {\n        if (!relativeStateValue) {\n          return stateNode.historyValue();\n        }\n\n        var subStateValue = isString(relativeStateValue) ? undefined : relativeStateValue[key];\n        return stateNode.historyValue(subStateValue || stateNode.initialStateValue);\n      }, function (stateNode) {\n        return !stateNode.history;\n      })\n    };\n  };\n  /**\r\n   * Resolves to the historical value(s) of the parent state node,\r\n   * represented by state nodes.\r\n   *\r\n   * @param historyValue\r\n   */\n\n\n  StateNode.prototype.resolveHistory = function (historyValue) {\n    var _this = this;\n\n    if (this.type !== 'history') {\n      return [this];\n    }\n\n    var parent = this.parent;\n\n    if (!historyValue) {\n      var historyTarget = this.target;\n      return historyTarget ? flatten(toStatePaths(historyTarget).map(function (relativeChildPath) {\n        return parent.getFromRelativePath(relativeChildPath);\n      })) : parent.initialStateNodes;\n    }\n\n    var subHistoryValue = nestedPath(parent.path, 'states')(historyValue).current;\n\n    if (isString(subHistoryValue)) {\n      return [parent.getStateNode(subHistoryValue)];\n    }\n\n    return flatten(toStatePaths(subHistoryValue).map(function (subStatePath) {\n      return _this.history === 'deep' ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];\n    }));\n  };\n\n  Object.defineProperty(StateNode.prototype, \"stateIds\", {\n    /**\r\n     * All the state node IDs of this state node and its descendant state nodes.\r\n     */\n    get: function () {\n      var _this = this;\n\n      var childStateIds = flatten(keys(this.states).map(function (stateKey) {\n        return _this.states[stateKey].stateIds;\n      }));\n      return [this.id].concat(childStateIds);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"events\", {\n    /**\r\n     * All the event types accepted by this state node and its descendants.\r\n     */\n    get: function () {\n      var e_7, _a, e_8, _b;\n\n      if (this.__cache.events) {\n        return this.__cache.events;\n      }\n\n      var states = this.states;\n      var events = new Set(this.ownEvents);\n\n      if (states) {\n        try {\n          for (var _c = __values(keys(states)), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var stateId = _d.value;\n            var state = states[stateId];\n\n            if (state.states) {\n              try {\n                for (var _e = (e_8 = void 0, __values(state.events)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                  var event_1 = _f.value;\n                  events.add(\"\" + event_1);\n                }\n              } catch (e_8_1) {\n                e_8 = {\n                  error: e_8_1\n                };\n              } finally {\n                try {\n                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                } finally {\n                  if (e_8) throw e_8.error;\n                }\n              }\n            }\n          }\n        } catch (e_7_1) {\n          e_7 = {\n            error: e_7_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_7) throw e_7.error;\n          }\n        }\n      }\n\n      return this.__cache.events = Array.from(events);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"ownEvents\", {\n    /**\r\n     * All the events that have transitions directly from this state node.\r\n     *\r\n     * Excludes any inert events.\r\n     */\n    get: function () {\n      var events = new Set(this.transitions.filter(function (transition) {\n        return !(!transition.target && !transition.actions.length && transition.internal);\n      }).map(function (transition) {\n        return transition.eventType;\n      }));\n      return Array.from(events);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateNode.prototype.resolveTarget = function (_target) {\n    var _this = this;\n\n    if (_target === undefined) {\n      // an undefined target signals that the state node should not transition from that state when receiving that event\n      return undefined;\n    }\n\n    return _target.map(function (target) {\n      if (!isString(target)) {\n        return target;\n      }\n\n      var isInternalTarget = target[0] === _this.delimiter; // If internal target is defined on machine,\n      // do not include machine key on target\n\n      if (isInternalTarget && !_this.parent) {\n        return _this.getStateNodeByPath(target.slice(1));\n      }\n\n      var resolvedTarget = isInternalTarget ? _this.key + target : target;\n\n      if (_this.parent) {\n        try {\n          var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);\n\n          return targetStateNode;\n        } catch (err) {\n          throw new Error(\"Invalid transition definition for state node '\" + _this.id + \"':\\n\" + err.message);\n        }\n      } else {\n        return _this.getStateNodeByPath(resolvedTarget);\n      }\n    });\n  };\n\n  StateNode.prototype.formatTransition = function (transitionConfig) {\n    var _this = this;\n\n    var normalizedTarget = normalizeTarget(transitionConfig.target);\n    var internal = 'internal' in transitionConfig ? transitionConfig.internal : normalizedTarget ? normalizedTarget.some(function (_target) {\n      return isString(_target) && _target[0] === _this.delimiter;\n    }) : true;\n    var guards = this.machine.options.guards;\n    var target = this.resolveTarget(normalizedTarget);\n    return __assign(__assign({}, transitionConfig), {\n      actions: toActionObjects(toArray(transitionConfig.actions)),\n      cond: toGuard(transitionConfig.cond, guards),\n      target: target,\n      source: this,\n      internal: internal,\n      eventType: transitionConfig.event\n    });\n  };\n\n  StateNode.prototype.formatTransitions = function () {\n    var e_9, _a;\n\n    var _this = this;\n\n    var onConfig;\n\n    if (!this.config.on) {\n      onConfig = [];\n    } else if (Array.isArray(this.config.on)) {\n      onConfig = this.config.on;\n    } else {\n      var _b = this.config.on,\n          _c = WILDCARD,\n          _d = _b[_c],\n          wildcardConfigs = _d === void 0 ? [] : _d,\n          strictOnConfigs_1 = __rest(_b, [typeof _c === \"symbol\" ? _c : _c + \"\"]);\n\n      onConfig = flatten(keys(strictOnConfigs_1).map(function (key) {\n        var arrayified = toTransitionConfigArray(key, strictOnConfigs_1[key]);\n\n        if (!IS_PRODUCTION) {\n          validateArrayifiedTransitions(_this, key, arrayified);\n        }\n\n        return arrayified;\n      }).concat(toTransitionConfigArray(WILDCARD, wildcardConfigs)));\n    }\n\n    var doneConfig = this.config.onDone ? toTransitionConfigArray(String(done(this.id)), this.config.onDone) : [];\n    var invokeConfig = flatten(this.invoke.map(function (invokeDef) {\n      var settleTransitions = [];\n\n      if (invokeDef.onDone) {\n        settleTransitions.push.apply(settleTransitions, __spread(toTransitionConfigArray(String(doneInvoke(invokeDef.id)), invokeDef.onDone)));\n      }\n\n      if (invokeDef.onError) {\n        settleTransitions.push.apply(settleTransitions, __spread(toTransitionConfigArray(String(error(invokeDef.id)), invokeDef.onError)));\n      }\n\n      return settleTransitions;\n    }));\n    var delayedTransitions = this.after;\n    var formattedTransitions = flatten(__spread(doneConfig, invokeConfig, onConfig).map(function (transitionConfig) {\n      return toArray(transitionConfig).map(function (transition) {\n        return _this.formatTransition(transition);\n      });\n    }));\n\n    try {\n      for (var delayedTransitions_1 = __values(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {\n        var delayedTransition = delayedTransitions_1_1.value;\n        formattedTransitions.push(delayedTransition);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_a = delayedTransitions_1.return)) _a.call(delayedTransitions_1);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n\n    return formattedTransitions;\n  };\n\n  return StateNode;\n}();\n\nexport { StateNode };","map":{"version":3,"sources":["/Users/dmitriilobanov/Documents/projects/airport-demo/node_modules/xstate/es/StateNode.js"],"names":["__assign","__values","__spread","__read","__rest","DEFAULT_GUARD_TYPE","STATE_DELIMITER","IS_PRODUCTION","mapValues","isArray","flatten","keys","toArray","toStateValue","isString","getEventType","matchesState","path","mapContext","toSCXMLEvent","pathToStateValue","isBuiltInEvent","partition","updateContext","warn","updateHistoryValue","toStatePath","mapFilterValues","toStatePaths","nestedPath","normalizeTarget","toGuard","toTransitionConfigArray","isMachine","isFunction","SpecialTargets","getAllStateNodes","getConfiguration","has","getChildren","isInFinalState","getValue","isLeafNode","start","start$1","stop","stop$1","pure","log","send","raise","raise$1","invoke","update","nullEvent","assign","done","toActionObjects","toActionObject","resolveLog","resolveSend","resolveRaise","doneInvoke","error","toActivityDefinition","after","send$1","cancel","initEvent","State","stateValuesEqual","createInvocableActor","NULL_EVENT","STATE_IDENTIFIER","WILDCARD","EMPTY_OBJECT","isStateId","str","createDefaultOptions","actions","guards","services","activities","delays","validateArrayifiedTransitions","stateNode","event","transitions","hasNonLastUnguardedTarget","slice","some","transition","target","eventText","id","StateNode","config","options","context","_this","order","__xstatenode","__cache","events","undefined","relativeValue","Map","initialStateValue","initialState","on","candidates","delayedTransitions","idMap","Object","parent","_parent","key","_key","machine","concat","delimiter","join","version","type","parallel","states","length","history","initial","stateConfig","_a","dfs","e_1","_b","_c","next","child","value","e_1_1","return","call","_transient","Array","strict","onEntry","entry","map","action","onExit","exit","meta","data","invokeConfig","i","src","invokeSrc","activity","bind","prototype","_init","forEach","withConfig","withContext","defineProperty","get","state","definition","enumerable","configurable","toJSON","reduce","eventType","push","getDelayedTransitions","formatTransitions","getCandidates","eventName","transient","filter","sameEventType","afterConfig","mutateEntryExit","delay","delayRef","configTransition","resolvedTransition","resolvedDelay","isNaN","delayedTransition","formatTransition","getStateNodes","stateValue","getStateNode","subStateKeys","subStateNodes","subStateKey","allSubStateNodes","subStateNode","handles","includes","resolveState","configuration","from","resolve","transitionLeafNode","_event","transitionCompoundNode","_transition","transitionParallelNode","e_2","transitionMap","subStateValue","e_2_1","stateTransitions","enabledTransitions","st","willTransition","entryNodes","t","entrySet","exitSet","source","e_3","name","nextStateNodes","selectedTransition","candidate","cond","stateIn","in","resolvedContext","isInState","matches","getStateNodeById","guardPassed","evaluateGuard","err","Error","message","apply","e_3_1","allNextStateNodes","getRelativeStateNodes","historyValue","isInternal","internal","reentryNodes","n","nodesFromChild","childStateNode","escapes","nodes","marker","guard","guardMeta","predicate","condFn","getActions","currentContext","prevState","e_4","e_5","prevConfig","resolvedConfig","resolvedConfig_1","resolvedConfig_1_1","sn","e_4_1","prevConfig_1","prevConfig_1_1","e_5_1","doneEvents","grandparent","every","parentNode","sort","a","b","entryStates","Set","exitStates","entryActions","exitActions","currentState","resolvedStateValue","getResolvedPath","stateTransition","resolveTransition","resolveRaisedTransition","originalEvent","currentActions","unshift","e_6","actions_1","actions_1_1","e_6_1","assignActions","otherActions","updatedContext","resolvedActions","actionObject","sendAction","to","Internal","raisedEvents","nonRaisedActions","invokeActions","children","acc","resolvedConfiguration","isDone","nextState","_sessionid","changed","maybeNextState","isTransient","raisedEvent","shift","stateKey","result","stateId","resolvedStateId","getStateNodeByPath","statePath","e","arrayStatePath","currentStateNode","stateIdentifier","getInitialState","historyConfig","relativeStateId","resolveHistory","initialStateNodes","initialStateNodePaths","initialPath","getFromRelativePath","relativePath","childStatePath","relativeStateValue","current","historyTarget","relativeChildPath","subHistoryValue","subStatePath","childStateIds","stateIds","e_7","e_8","ownEvents","_d","_e","_f","event_1","add","e_8_1","e_7_1","resolveTarget","_target","isInternalTarget","resolvedTarget","targetStateNode","transitionConfig","normalizedTarget","e_9","onConfig","wildcardConfigs","strictOnConfigs_1","arrayified","doneConfig","onDone","String","invokeDef","settleTransitions","onError","formattedTransitions","delayedTransitions_1","delayedTransitions_1_1","e_9_1"],"mappings":"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","sourcesContent":["import { __assign, __values, __spread, __read, __rest } from './_virtual/_tslib.js';\nimport { DEFAULT_GUARD_TYPE, STATE_DELIMITER } from './constants.js';\nimport { IS_PRODUCTION } from './environment.js';\nimport { mapValues, isArray, flatten, keys, toArray, toStateValue, isString, getEventType, matchesState, path, mapContext, toSCXMLEvent, pathToStateValue, isBuiltInEvent, partition, updateContext, warn, updateHistoryValue, toStatePath, mapFilterValues, toStatePaths, nestedPath, normalizeTarget, toGuard, toTransitionConfigArray, isMachine, isFunction } from './utils.js';\nimport { SpecialTargets } from './types.js';\nimport { getAllStateNodes, getConfiguration, has, getChildren, isInFinalState, getValue, isLeafNode } from './stateUtils.js';\nimport { start as start$1, stop as stop$1, pure, log, send, raise as raise$1, invoke, update, nullEvent, assign } from './actionTypes.js';\nimport { done, start, raise, stop, toActionObjects, toActionObject, resolveLog, resolveSend, resolveRaise, doneInvoke, error, toActivityDefinition, after, send as send$1, cancel, initEvent } from './actions.js';\nimport { State, stateValuesEqual } from './State.js';\nimport { createInvocableActor } from './Actor.js';\nvar NULL_EVENT = '';\nvar STATE_IDENTIFIER = '#';\nvar WILDCARD = '*';\nvar EMPTY_OBJECT = {};\n\nvar isStateId = function (str) {\n  return str[0] === STATE_IDENTIFIER;\n};\n\nvar createDefaultOptions = function () {\n  return {\n    actions: {},\n    guards: {},\n    services: {},\n    activities: {},\n    delays: {}\n  };\n};\n\nvar validateArrayifiedTransitions = function (stateNode, event, transitions) {\n  var hasNonLastUnguardedTarget = transitions.slice(0, -1).some(function (transition) {\n    return !('cond' in transition) && !('in' in transition) && (isString(transition.target) || isMachine(transition.target));\n  });\n  var eventText = event === NULL_EVENT ? 'the transient event' : \"event '\" + event + \"'\";\n  warn(!hasNonLastUnguardedTarget, \"One or more transitions for \" + eventText + \" on state '\" + stateNode.id + \"' are unreachable. \" + \"Make sure that the default transition is the last one defined.\");\n};\n\nvar StateNode =\n/*#__PURE__*/\n\n/** @class */\nfunction () {\n  function StateNode(\n  /**\r\n   * The raw config used to create the machine.\r\n   */\n  config, options,\n  /**\r\n   * The initial extended state\r\n   */\n  context) {\n    var _this = this;\n\n    this.config = config;\n    this.context = context;\n    /**\r\n     * The order this state node appears. Corresponds to the implicit SCXML document order.\r\n     */\n\n    this.order = -1;\n    this.__xstatenode = true;\n    this.__cache = {\n      events: undefined,\n      relativeValue: new Map(),\n      initialStateValue: undefined,\n      initialState: undefined,\n      on: undefined,\n      transitions: undefined,\n      candidates: {},\n      delayedTransitions: undefined\n    };\n    this.idMap = {};\n    this.options = Object.assign(createDefaultOptions(), options);\n    this.parent = this.options._parent;\n    this.key = this.config.key || this.options._key || this.config.id || '(machine)';\n    this.machine = this.parent ? this.parent.machine : this;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : STATE_DELIMITER);\n    this.id = this.config.id || __spread([this.machine.key], this.path).join(this.delimiter);\n    this.version = this.parent ? this.parent.version : this.config.version;\n    this.type = this.config.type || (this.config.parallel ? 'parallel' : this.config.states && keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n\n    if (!IS_PRODUCTION) {\n      warn(!('parallel' in this.config), \"The \\\"parallel\\\" property is deprecated and will be removed in version 4.1. \" + (this.config.parallel ? \"Replace with `type: 'parallel'`\" : \"Use `type: '\" + this.type + \"'`\") + \" in the config for state node '\" + this.id + \"' instead.\");\n    }\n\n    this.initial = this.config.initial;\n    this.states = this.config.states ? mapValues(this.config.states, function (stateConfig, key) {\n      var _a;\n\n      var stateNode = new StateNode(stateConfig, {\n        _parent: _this,\n        _key: key\n      });\n      Object.assign(_this.idMap, __assign((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));\n      return stateNode;\n    }) : EMPTY_OBJECT; // Document order\n\n    var order = 0;\n\n    function dfs(stateNode) {\n      var e_1, _a;\n\n      stateNode.order = order++;\n\n      try {\n        for (var _b = __values(getChildren(stateNode)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          dfs(child);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    dfs(this); // History config\n\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this._transient = !this.config.on ? false : Array.isArray(this.config.on) ? this.config.on.some(function (_a) {\n      var event = _a.event;\n      return event === NULL_EVENT;\n    }) : NULL_EVENT in this.config.on;\n    this.strict = !!this.config.strict; // TODO: deprecate (entry)\n\n    this.onEntry = toArray(this.config.entry || this.config.onEntry).map(function (action) {\n      return toActionObject(action);\n    }); // TODO: deprecate (exit)\n\n    this.onExit = toArray(this.config.exit || this.config.onExit).map(function (action) {\n      return toActionObject(action);\n    });\n    this.meta = this.config.meta;\n    this.data = this.type === 'final' ? this.config.data : undefined;\n    this.invoke = toArray(this.config.invoke).map(function (invokeConfig, i) {\n      var _a, _b;\n\n      if (isMachine(invokeConfig)) {\n        _this.machine.options.services = __assign((_a = {}, _a[invokeConfig.id] = invokeConfig, _a), _this.machine.options.services);\n        return {\n          type: invoke,\n          src: invokeConfig.id,\n          id: invokeConfig.id\n        };\n      } else if (typeof invokeConfig.src !== 'string') {\n        var invokeSrc = _this.id + \":invocation[\" + i + \"]\"; // TODO: util function\n\n        _this.machine.options.services = __assign((_b = {}, _b[invokeSrc] = invokeConfig.src, _b), _this.machine.options.services);\n        return __assign(__assign({\n          type: invoke,\n          id: invokeSrc\n        }, invokeConfig), {\n          src: invokeSrc\n        });\n      } else {\n        return __assign(__assign({}, invokeConfig), {\n          type: invoke,\n          id: invokeConfig.id || invokeConfig.src,\n          src: invokeConfig.src\n        });\n      }\n    });\n    this.activities = toArray(this.config.activities).concat(this.invoke).map(function (activity) {\n      return toActivityDefinition(activity);\n    });\n    this.transition = this.transition.bind(this);\n  }\n\n  StateNode.prototype._init = function () {\n    if (this.__cache.transitions) {\n      return;\n    }\n\n    getAllStateNodes(this).forEach(function (stateNode) {\n      return stateNode.on;\n    });\n  };\n  /**\r\n   * Clones this state machine with custom options and context.\r\n   *\r\n   * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.\r\n   * @param context Custom context (will override predefined context)\r\n   */\n\n\n  StateNode.prototype.withConfig = function (options, context) {\n    if (context === void 0) {\n      context = this.context;\n    }\n\n    var _a = this.options,\n        actions = _a.actions,\n        activities = _a.activities,\n        guards = _a.guards,\n        services = _a.services,\n        delays = _a.delays;\n    return new StateNode(this.config, {\n      actions: __assign(__assign({}, actions), options.actions),\n      activities: __assign(__assign({}, activities), options.activities),\n      guards: __assign(__assign({}, guards), options.guards),\n      services: __assign(__assign({}, services), options.services),\n      delays: __assign(__assign({}, delays), options.delays)\n    }, context);\n  };\n  /**\r\n   * Clones this state machine with custom context.\r\n   *\r\n   * @param context Custom context (will override predefined context, not recursive)\r\n   */\n\n\n  StateNode.prototype.withContext = function (context) {\n    return new StateNode(this.config, this.options, context);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"definition\", {\n    /**\r\n     * The well-structured state node definition.\r\n     */\n    get: function () {\n      return {\n        id: this.id,\n        key: this.key,\n        version: this.version,\n        type: this.type,\n        initial: this.initial,\n        history: this.history,\n        states: mapValues(this.states, function (state) {\n          return state.definition;\n        }),\n        on: this.on,\n        transitions: this.transitions,\n        onEntry: this.onEntry,\n        onExit: this.onExit,\n        activities: this.activities || [],\n        meta: this.meta,\n        order: this.order || -1,\n        data: this.data,\n        invoke: this.invoke\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateNode.prototype.toJSON = function () {\n    return this.definition;\n  };\n\n  Object.defineProperty(StateNode.prototype, \"on\", {\n    /**\r\n     * The mapping of events to transitions.\r\n     */\n    get: function () {\n      if (this.__cache.on) {\n        return this.__cache.on;\n      }\n\n      var transitions = this.transitions;\n      return this.__cache.on = transitions.reduce(function (map, transition) {\n        map[transition.eventType] = map[transition.eventType] || [];\n        map[transition.eventType].push(transition);\n        return map;\n      }, {});\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"after\", {\n    get: function () {\n      return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"transitions\", {\n    /**\r\n     * All the transitions that can be taken from this state node.\r\n     */\n    get: function () {\n      return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateNode.prototype.getCandidates = function (eventName) {\n    if (this.__cache.candidates[eventName]) {\n      return this.__cache.candidates[eventName];\n    }\n\n    var transient = eventName === NULL_EVENT;\n    var candidates = this.transitions.filter(function (transition) {\n      var sameEventType = transition.eventType === eventName; // null events should only match against eventless transitions\n\n      return transient ? sameEventType : sameEventType || transition.eventType === WILDCARD;\n    });\n    this.__cache.candidates[eventName] = candidates;\n    return candidates;\n  };\n  /**\r\n   * All delayed transitions from the config.\r\n   */\n\n\n  StateNode.prototype.getDelayedTransitions = function () {\n    var _this = this;\n\n    var afterConfig = this.config.after;\n\n    if (!afterConfig) {\n      return [];\n    }\n\n    var mutateEntryExit = function (delay, i) {\n      var delayRef = isFunction(delay) ? _this.id + \":delay[\" + i + \"]\" : delay;\n      var eventType = after(delayRef, _this.id);\n\n      _this.onEntry.push(send$1(eventType, {\n        delay: delay\n      }));\n\n      _this.onExit.push(cancel(eventType));\n\n      return eventType;\n    };\n\n    var delayedTransitions = isArray(afterConfig) ? afterConfig.map(function (transition, i) {\n      var eventType = mutateEntryExit(transition.delay, i);\n      return __assign(__assign({}, transition), {\n        event: eventType\n      });\n    }) : flatten(keys(afterConfig).map(function (delay, i) {\n      var configTransition = afterConfig[delay];\n      var resolvedTransition = isString(configTransition) ? {\n        target: configTransition\n      } : configTransition;\n      var resolvedDelay = !isNaN(+delay) ? +delay : delay;\n      var eventType = mutateEntryExit(resolvedDelay, i);\n      return toArray(resolvedTransition).map(function (transition) {\n        return __assign(__assign({}, transition), {\n          event: eventType,\n          delay: resolvedDelay\n        });\n      });\n    }));\n    return delayedTransitions.map(function (delayedTransition) {\n      var delay = delayedTransition.delay;\n      return __assign(__assign({}, _this.formatTransition(delayedTransition)), {\n        delay: delay\n      });\n    });\n  };\n  /**\r\n   * Returns the state nodes represented by the current state value.\r\n   *\r\n   * @param state The state value or State instance\r\n   */\n\n\n  StateNode.prototype.getStateNodes = function (state) {\n    var _a;\n\n    var _this = this;\n\n    if (!state) {\n      return [];\n    }\n\n    var stateValue = state instanceof State ? state.value : toStateValue(state, this.delimiter);\n\n    if (isString(stateValue)) {\n      var initialStateValue = this.getStateNode(stateValue).initial;\n      return initialStateValue !== undefined ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a)) : [this.states[stateValue]];\n    }\n\n    var subStateKeys = keys(stateValue);\n    var subStateNodes = subStateKeys.map(function (subStateKey) {\n      return _this.getStateNode(subStateKey);\n    });\n    return subStateNodes.concat(subStateKeys.reduce(function (allSubStateNodes, subStateKey) {\n      var subStateNode = _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);\n\n      return allSubStateNodes.concat(subStateNode);\n    }, []));\n  };\n  /**\r\n   * Returns `true` if this state node explicitly handles the given event.\r\n   *\r\n   * @param event The event in question\r\n   */\n\n\n  StateNode.prototype.handles = function (event) {\n    var eventType = getEventType(event);\n    return this.events.includes(eventType);\n  };\n  /**\r\n   * Resolves the given `state` to a new `State` instance relative to this machine.\r\n   *\r\n   * This ensures that `.events` and `.nextEvents` represent the correct values.\r\n   *\r\n   * @param state The state to resolve\r\n   */\n\n\n  StateNode.prototype.resolveState = function (state) {\n    var configuration = Array.from(getConfiguration([], this.getStateNodes(state.value)));\n    return new State(__assign(__assign({}, state), {\n      value: this.resolve(state.value),\n      configuration: configuration\n    }));\n  };\n\n  StateNode.prototype.transitionLeafNode = function (stateValue, state, _event) {\n    var stateNode = this.getStateNode(stateValue);\n    var next = stateNode.next(state, _event);\n\n    if (!next || !next.transitions.length) {\n      return this.next(state, _event);\n    }\n\n    return next;\n  };\n\n  StateNode.prototype.transitionCompoundNode = function (stateValue, state, _event) {\n    var subStateKeys = keys(stateValue);\n    var stateNode = this.getStateNode(subStateKeys[0]);\n\n    var next = stateNode._transition(stateValue[subStateKeys[0]], state, _event);\n\n    if (!next || !next.transitions.length) {\n      return this.next(state, _event);\n    }\n\n    return next;\n  };\n\n  StateNode.prototype.transitionParallelNode = function (stateValue, state, _event) {\n    var e_2, _a;\n\n    var transitionMap = {};\n\n    try {\n      for (var _b = __values(keys(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var subStateKey = _c.value;\n        var subStateValue = stateValue[subStateKey];\n\n        if (!subStateValue) {\n          continue;\n        }\n\n        var subStateNode = this.getStateNode(subStateKey);\n\n        var next = subStateNode._transition(subStateValue, state, _event);\n\n        if (next) {\n          transitionMap[subStateKey] = next;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    var stateTransitions = keys(transitionMap).map(function (key) {\n      return transitionMap[key];\n    });\n    var enabledTransitions = flatten(stateTransitions.map(function (st) {\n      return st.transitions;\n    }));\n    var willTransition = stateTransitions.some(function (st) {\n      return st.transitions.length > 0;\n    });\n\n    if (!willTransition) {\n      return this.next(state, _event);\n    }\n\n    var entryNodes = flatten(stateTransitions.map(function (t) {\n      return t.entrySet;\n    }));\n    var configuration = flatten(keys(transitionMap).map(function (key) {\n      return transitionMap[key].configuration;\n    }));\n    return {\n      transitions: enabledTransitions,\n      entrySet: entryNodes,\n      exitSet: flatten(stateTransitions.map(function (t) {\n        return t.exitSet;\n      })),\n      configuration: configuration,\n      source: state,\n      actions: flatten(keys(transitionMap).map(function (key) {\n        return transitionMap[key].actions;\n      }))\n    };\n  };\n\n  StateNode.prototype._transition = function (stateValue, state, _event) {\n    // leaf node\n    if (isString(stateValue)) {\n      return this.transitionLeafNode(stateValue, state, _event);\n    } // hierarchical node\n\n\n    if (keys(stateValue).length === 1) {\n      return this.transitionCompoundNode(stateValue, state, _event);\n    } // orthogonal node\n\n\n    return this.transitionParallelNode(stateValue, state, _event);\n  };\n\n  StateNode.prototype.next = function (state, _event) {\n    var e_3, _a;\n\n    var _this = this;\n\n    var eventName = _event.name;\n    var actions = [];\n    var nextStateNodes = [];\n    var selectedTransition;\n\n    try {\n      for (var _b = __values(this.getCandidates(eventName)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var candidate = _c.value;\n        var cond = candidate.cond,\n            stateIn = candidate.in;\n        var resolvedContext = state.context;\n        var isInState = stateIn ? isString(stateIn) && isStateId(stateIn) ? // Check if in state by ID\n        state.matches(toStateValue(this.getStateNodeById(stateIn).path, this.delimiter)) : // Check if in state by relative grandparent\n        matchesState(toStateValue(stateIn, this.delimiter), path(this.path.slice(0, -2))(state.value)) : true;\n        var guardPassed = false;\n\n        try {\n          guardPassed = !cond || this.evaluateGuard(cond, resolvedContext, _event, state);\n        } catch (err) {\n          throw new Error(\"Unable to evaluate guard '\" + (cond.name || cond.type) + \"' in transition for event '\" + eventName + \"' in state node '\" + this.id + \"':\\n\" + err.message);\n        }\n\n        if (guardPassed && isInState) {\n          if (candidate.target !== undefined) {\n            nextStateNodes = candidate.target;\n          }\n\n          actions.push.apply(actions, __spread(candidate.actions));\n          selectedTransition = candidate;\n          break;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    if (!selectedTransition) {\n      return undefined;\n    }\n\n    if (!nextStateNodes.length) {\n      return {\n        transitions: [selectedTransition],\n        entrySet: [],\n        exitSet: [],\n        configuration: state.value ? [this] : [],\n        source: state,\n        actions: actions\n      };\n    }\n\n    var allNextStateNodes = flatten(nextStateNodes.map(function (stateNode) {\n      return _this.getRelativeStateNodes(stateNode, state.historyValue);\n    }));\n    var isInternal = !!selectedTransition.internal;\n    var reentryNodes = isInternal ? [] : flatten(allNextStateNodes.map(function (n) {\n      return _this.nodesFromChild(n);\n    }));\n    return {\n      transitions: [selectedTransition],\n      entrySet: reentryNodes,\n      exitSet: isInternal ? [] : [this],\n      configuration: allNextStateNodes,\n      source: state,\n      actions: actions\n    };\n  };\n\n  StateNode.prototype.nodesFromChild = function (childStateNode) {\n    if (childStateNode.escapes(this)) {\n      return [];\n    }\n\n    var nodes = [];\n    var marker = childStateNode;\n\n    while (marker && marker !== this) {\n      nodes.push(marker);\n      marker = marker.parent;\n    }\n\n    nodes.push(this); // inclusive\n\n    return nodes;\n  };\n  /**\r\n   * Whether the given state node \"escapes\" this state node. If the `stateNode` is equal to or the parent of\r\n   * this state node, it does not escape.\r\n   */\n\n\n  StateNode.prototype.escapes = function (stateNode) {\n    if (this === stateNode) {\n      return false;\n    }\n\n    var parent = this.parent;\n\n    while (parent) {\n      if (parent === stateNode) {\n        return false;\n      }\n\n      parent = parent.parent;\n    }\n\n    return true;\n  };\n\n  StateNode.prototype.evaluateGuard = function (guard, context, _event, state) {\n    var guards = this.machine.options.guards;\n    var guardMeta = {\n      state: state,\n      cond: guard,\n      _event: _event\n    }; // TODO: do not hardcode!\n\n    if (guard.type === DEFAULT_GUARD_TYPE) {\n      return guard.predicate(context, _event.data, guardMeta);\n    }\n\n    var condFn = guards[guard.type];\n\n    if (!condFn) {\n      throw new Error(\"Guard '\" + guard.type + \"' is not implemented on machine '\" + this.machine.id + \"'.\");\n    }\n\n    return condFn(context, _event.data, guardMeta);\n  };\n\n  StateNode.prototype.getActions = function (transition, currentContext, _event, prevState) {\n    var e_4, _a, e_5, _b;\n\n    var prevConfig = getConfiguration([], prevState ? this.getStateNodes(prevState.value) : [this]);\n    var resolvedConfig = transition.configuration.length ? getConfiguration(prevConfig, transition.configuration) : prevConfig;\n\n    try {\n      for (var resolvedConfig_1 = __values(resolvedConfig), resolvedConfig_1_1 = resolvedConfig_1.next(); !resolvedConfig_1_1.done; resolvedConfig_1_1 = resolvedConfig_1.next()) {\n        var sn = resolvedConfig_1_1.value;\n\n        if (!has(prevConfig, sn)) {\n          transition.entrySet.push(sn);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (resolvedConfig_1_1 && !resolvedConfig_1_1.done && (_a = resolvedConfig_1.return)) _a.call(resolvedConfig_1);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    try {\n      for (var prevConfig_1 = __values(prevConfig), prevConfig_1_1 = prevConfig_1.next(); !prevConfig_1_1.done; prevConfig_1_1 = prevConfig_1.next()) {\n        var sn = prevConfig_1_1.value;\n\n        if (!has(resolvedConfig, sn) || has(transition.exitSet, sn.parent)) {\n          transition.exitSet.push(sn);\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (prevConfig_1_1 && !prevConfig_1_1.done && (_b = prevConfig_1.return)) _b.call(prevConfig_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    if (!transition.source) {\n      transition.exitSet = []; // Ensure that root StateNode (machine) is entered\n\n      transition.entrySet.push(this);\n    }\n\n    var doneEvents = flatten(transition.entrySet.map(function (sn) {\n      var events = [];\n\n      if (sn.type !== 'final') {\n        return events;\n      }\n\n      var parent = sn.parent;\n      events.push(done(sn.id, sn.data), // TODO: deprecate - final states should not emit done events for their own state.\n      done(parent.id, sn.data ? mapContext(sn.data, currentContext, _event) : undefined));\n\n      if (parent.parent) {\n        var grandparent = parent.parent;\n\n        if (grandparent.type === 'parallel') {\n          if (getChildren(grandparent).every(function (parentNode) {\n            return isInFinalState(transition.configuration, parentNode);\n          })) {\n            events.push(done(grandparent.id, grandparent.data));\n          }\n        }\n      }\n\n      return events;\n    }));\n    transition.exitSet.sort(function (a, b) {\n      return b.order - a.order;\n    });\n    transition.entrySet.sort(function (a, b) {\n      return a.order - b.order;\n    });\n    var entryStates = new Set(transition.entrySet);\n    var exitStates = new Set(transition.exitSet);\n\n    var _c = __read([flatten(Array.from(entryStates).map(function (stateNode) {\n      return __spread(stateNode.activities.map(function (activity) {\n        return start(activity);\n      }), stateNode.onEntry);\n    })).concat(doneEvents.map(raise)), flatten(Array.from(exitStates).map(function (stateNode) {\n      return __spread(stateNode.onExit, stateNode.activities.map(function (activity) {\n        return stop(activity);\n      }));\n    }))], 2),\n        entryActions = _c[0],\n        exitActions = _c[1];\n\n    var actions = toActionObjects(exitActions.concat(transition.actions).concat(entryActions), this.machine.options.actions);\n    return actions;\n  };\n  /**\r\n   * Determines the next state given the current `state` and sent `event`.\r\n   *\r\n   * @param state The current State instance or state value\r\n   * @param event The event that was sent at the current state\r\n   * @param context The current context (extended state) of the current state\r\n   */\n\n\n  StateNode.prototype.transition = function (state, event, context) {\n    if (state === void 0) {\n      state = this.initialState;\n    }\n\n    var _event = toSCXMLEvent(event);\n\n    var currentState;\n\n    if (state instanceof State) {\n      currentState = context === undefined ? state : this.resolveState(State.from(state, context));\n    } else {\n      var resolvedStateValue = isString(state) ? this.resolve(pathToStateValue(this.getResolvedPath(state))) : this.resolve(state);\n      var resolvedContext = context ? context : this.machine.context;\n      currentState = this.resolveState(State.from(resolvedStateValue, resolvedContext));\n    }\n\n    if (!IS_PRODUCTION && _event.name === WILDCARD) {\n      throw new Error(\"An event cannot have the wildcard type ('\" + WILDCARD + \"')\");\n    }\n\n    if (this.strict) {\n      if (!this.events.includes(_event.name) && !isBuiltInEvent(_event.name)) {\n        throw new Error(\"Machine '\" + this.id + \"' does not accept event '\" + _event.name + \"'\");\n      }\n    }\n\n    var stateTransition = this._transition(currentState.value, currentState, _event) || {\n      transitions: [],\n      configuration: [],\n      entrySet: [],\n      exitSet: [],\n      source: currentState,\n      actions: []\n    };\n    var prevConfig = getConfiguration([], this.getStateNodes(currentState.value));\n    var resolvedConfig = stateTransition.configuration.length ? getConfiguration(prevConfig, stateTransition.configuration) : prevConfig;\n    stateTransition.configuration = __spread(resolvedConfig);\n    return this.resolveTransition(stateTransition, currentState, _event);\n  };\n\n  StateNode.prototype.resolveRaisedTransition = function (state, _event, originalEvent) {\n    var _a;\n\n    var currentActions = state.actions;\n    state = this.transition(state, _event); // Save original event to state\n\n    state._event = originalEvent;\n    state.event = originalEvent.data;\n\n    (_a = state.actions).unshift.apply(_a, __spread(currentActions));\n\n    return state;\n  };\n\n  StateNode.prototype.resolveTransition = function (stateTransition, currentState, _event, context) {\n    var e_6, _a;\n\n    var _this = this;\n\n    if (_event === void 0) {\n      _event = initEvent;\n    }\n\n    if (context === void 0) {\n      context = this.machine.context;\n    }\n\n    var configuration = stateTransition.configuration; // Transition will \"apply\" if:\n    // - this is the initial state (there is no current state)\n    // - OR there are transitions\n\n    var willTransition = !currentState || stateTransition.transitions.length > 0;\n    var resolvedStateValue = willTransition ? getValue(this.machine, configuration) : undefined;\n    var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : undefined : undefined;\n    var currentContext = currentState ? currentState.context : context;\n    var actions = this.getActions(stateTransition, currentContext, _event, currentState);\n    var activities = currentState ? __assign({}, currentState.activities) : {};\n\n    try {\n      for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {\n        var action = actions_1_1.value;\n\n        if (action.type === start$1) {\n          activities[action.activity.type] = action;\n        } else if (action.type === stop$1) {\n          activities[action.activity.type] = false;\n        }\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    var _b = __read(partition(actions, function (action) {\n      return action.type === assign;\n    }), 2),\n        assignActions = _b[0],\n        otherActions = _b[1];\n\n    var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n    var resolvedActions = flatten(otherActions.map(function (actionObject) {\n      switch (actionObject.type) {\n        case raise$1:\n          return resolveRaise(actionObject);\n\n        case send:\n          var sendAction = resolveSend(actionObject, updatedContext, _event, _this.machine.options.delays); // TODO: fix ActionTypes.Init\n\n          if (!IS_PRODUCTION) {\n            // warn after resolving as we can create better contextual message here\n            warn(!isString(actionObject.delay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length\n            \"No delay reference for delay expression '\" + actionObject.delay + \"' was found on machine '\" + _this.machine.id + \"'\");\n          }\n\n          return sendAction;\n\n        case log:\n          return resolveLog(actionObject, updatedContext, _event);\n\n        case pure:\n          return actionObject.get(updatedContext, _event.data) || [];\n\n        default:\n          return toActionObject(actionObject, _this.options.actions);\n      }\n    }));\n\n    var _c = __read(partition(resolvedActions, function (action) {\n      return action.type === raise$1 || action.type === send && action.to === SpecialTargets.Internal;\n    }), 2),\n        raisedEvents = _c[0],\n        nonRaisedActions = _c[1];\n\n    var invokeActions = resolvedActions.filter(function (action) {\n      return action.type === start$1 && action.activity.type === invoke;\n    });\n    var children = invokeActions.reduce(function (acc, action) {\n      acc[action.activity.id] = createInvocableActor(action.activity);\n      return acc;\n    }, currentState ? __assign({}, currentState.children) : {});\n    var resolvedConfiguration = resolvedStateValue ? stateTransition.configuration : currentState ? currentState.configuration : [];\n    var meta = resolvedConfiguration.reduce(function (acc, stateNode) {\n      if (stateNode.meta !== undefined) {\n        acc[stateNode.id] = stateNode.meta;\n      }\n\n      return acc;\n    }, {});\n    var isDone = isInFinalState(resolvedConfiguration, this);\n    var nextState = new State({\n      value: resolvedStateValue || currentState.value,\n      context: updatedContext,\n      _event: _event,\n      // Persist _sessionid between states\n      _sessionid: currentState ? currentState._sessionid : null,\n      historyValue: resolvedStateValue ? historyValue ? updateHistoryValue(historyValue, resolvedStateValue) : undefined : currentState ? currentState.historyValue : undefined,\n      history: !resolvedStateValue || stateTransition.source ? currentState : undefined,\n      actions: resolvedStateValue ? nonRaisedActions : [],\n      activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},\n      meta: resolvedStateValue ? meta : currentState ? currentState.meta : undefined,\n      events: [],\n      configuration: resolvedConfiguration,\n      transitions: stateTransition.transitions,\n      children: children,\n      done: isDone\n    });\n    nextState.changed = _event.name === update || !!assignActions.length; // Dispose of penultimate histories to prevent memory leaks\n\n    var history = nextState.history;\n\n    if (history) {\n      delete history.history;\n    }\n\n    if (!resolvedStateValue) {\n      return nextState;\n    }\n\n    var maybeNextState = nextState;\n\n    if (!isDone) {\n      var isTransient = this._transient || configuration.some(function (stateNode) {\n        return stateNode._transient;\n      });\n\n      if (isTransient) {\n        maybeNextState = this.resolveRaisedTransition(maybeNextState, {\n          type: nullEvent\n        }, _event);\n      }\n\n      while (raisedEvents.length) {\n        var raisedEvent = raisedEvents.shift();\n        maybeNextState = this.resolveRaisedTransition(maybeNextState, raisedEvent._event, _event);\n      }\n    } // Detect if state changed\n\n\n    var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || !!assignActions.length || typeof history.value !== typeof maybeNextState.value || !stateValuesEqual(maybeNextState.value, history.value) : undefined);\n    maybeNextState.changed = changed; // Preserve original history after raised events\n\n    maybeNextState.historyValue = nextState.historyValue;\n    maybeNextState.history = history;\n    return maybeNextState;\n  };\n  /**\r\n   * Returns the child state node from its relative `stateKey`, or throws.\r\n   */\n\n\n  StateNode.prototype.getStateNode = function (stateKey) {\n    if (isStateId(stateKey)) {\n      return this.machine.getStateNodeById(stateKey);\n    }\n\n    if (!this.states) {\n      throw new Error(\"Unable to retrieve child state '\" + stateKey + \"' from '\" + this.id + \"'; no child states exist.\");\n    }\n\n    var result = this.states[stateKey];\n\n    if (!result) {\n      throw new Error(\"Child state '\" + stateKey + \"' does not exist on '\" + this.id + \"'\");\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns the state node with the given `stateId`, or throws.\r\n   *\r\n   * @param stateId The state ID. The prefix \"#\" is removed.\r\n   */\n\n\n  StateNode.prototype.getStateNodeById = function (stateId) {\n    var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;\n\n    if (resolvedStateId === this.id) {\n      return this;\n    }\n\n    var stateNode = this.machine.idMap[resolvedStateId];\n\n    if (!stateNode) {\n      throw new Error(\"Child state node '#\" + resolvedStateId + \"' does not exist on machine '\" + this.id + \"'\");\n    }\n\n    return stateNode;\n  };\n  /**\r\n   * Returns the relative state node from the given `statePath`, or throws.\r\n   *\r\n   * @param statePath The string or string array relative path to the state node.\r\n   */\n\n\n  StateNode.prototype.getStateNodeByPath = function (statePath) {\n    if (typeof statePath === 'string' && isStateId(statePath)) {\n      try {\n        return this.getStateNodeById(statePath.slice(1));\n      } catch (e) {// try individual paths\n        // throw e;\n      }\n    }\n\n    var arrayStatePath = toStatePath(statePath, this.delimiter).slice();\n    var currentStateNode = this;\n\n    while (arrayStatePath.length) {\n      var key = arrayStatePath.shift();\n\n      if (!key.length) {\n        break;\n      }\n\n      currentStateNode = currentStateNode.getStateNode(key);\n    }\n\n    return currentStateNode;\n  };\n  /**\r\n   * Resolves a partial state value with its full representation in this machine.\r\n   *\r\n   * @param stateValue The partial state value to resolve.\r\n   */\n\n\n  StateNode.prototype.resolve = function (stateValue) {\n    var _a;\n\n    var _this = this;\n\n    if (!stateValue) {\n      return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties\n    }\n\n    switch (this.type) {\n      case 'parallel':\n        return mapValues(this.initialStateValue, function (subStateValue, subStateKey) {\n          return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;\n        });\n\n      case 'compound':\n        if (isString(stateValue)) {\n          var subStateNode = this.getStateNode(stateValue);\n\n          if (subStateNode.type === 'parallel' || subStateNode.type === 'compound') {\n            return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;\n          }\n\n          return stateValue;\n        }\n\n        if (!keys(stateValue).length) {\n          return this.initialStateValue || {};\n        }\n\n        return mapValues(stateValue, function (subStateValue, subStateKey) {\n          return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;\n        });\n\n      default:\n        return stateValue || EMPTY_OBJECT;\n    }\n  };\n\n  StateNode.prototype.getResolvedPath = function (stateIdentifier) {\n    if (isStateId(stateIdentifier)) {\n      var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];\n\n      if (!stateNode) {\n        throw new Error(\"Unable to find state node '\" + stateIdentifier + \"'\");\n      }\n\n      return stateNode.path;\n    }\n\n    return toStatePath(stateIdentifier, this.delimiter);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialStateValue\", {\n    get: function () {\n      var _a;\n\n      if (this.__cache.initialStateValue) {\n        return this.__cache.initialStateValue;\n      }\n\n      var initialStateValue;\n\n      if (this.type === 'parallel') {\n        initialStateValue = mapFilterValues(this.states, function (state) {\n          return state.initialStateValue || EMPTY_OBJECT;\n        }, function (stateNode) {\n          return !(stateNode.type === 'history');\n        });\n      } else if (this.initial !== undefined) {\n        if (!this.states[this.initial]) {\n          throw new Error(\"Initial state '\" + this.initial + \"' not found on '\" + this.key + \"'\");\n        }\n\n        initialStateValue = isLeafNode(this.states[this.initial]) ? this.initial : (_a = {}, _a[this.initial] = this.states[this.initial].initialStateValue, _a);\n      }\n\n      this.__cache.initialStateValue = initialStateValue;\n      return this.__cache.initialStateValue;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateNode.prototype.getInitialState = function (stateValue, context) {\n    var configuration = this.getStateNodes(stateValue);\n    return this.resolveTransition({\n      configuration: configuration,\n      entrySet: configuration,\n      exitSet: [],\n      transitions: [],\n      source: undefined,\n      actions: []\n    }, undefined, undefined, context);\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialState\", {\n    /**\r\n     * The initial State instance, which includes all actions to be executed from\r\n     * entering the initial state.\r\n     */\n    get: function () {\n      this._init();\n\n      var initialStateValue = this.initialStateValue;\n\n      if (!initialStateValue) {\n        throw new Error(\"Cannot retrieve initial state from simple state '\" + this.id + \"'.\");\n      }\n\n      return this.getInitialState(initialStateValue);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"target\", {\n    /**\r\n     * The target state value of the history state node, if it exists. This represents the\r\n     * default state value to transition to if no history value exists yet.\r\n     */\n    get: function () {\n      var target;\n\n      if (this.type === 'history') {\n        var historyConfig = this.config;\n\n        if (isString(historyConfig.target)) {\n          target = isStateId(historyConfig.target) ? pathToStateValue(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;\n        } else {\n          target = historyConfig.target;\n        }\n      }\n\n      return target;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns the leaf nodes from a state path relative to this state node.\r\n   *\r\n   * @param relativeStateId The relative state path to retrieve the state nodes\r\n   * @param history The previous state to retrieve history\r\n   * @param resolve Whether state nodes should resolve to initial child state nodes\r\n   */\n\n  StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {\n    if (resolve === void 0) {\n      resolve = true;\n    }\n\n    return resolve ? relativeStateId.type === 'history' ? relativeStateId.resolveHistory(historyValue) : relativeStateId.initialStateNodes : [relativeStateId];\n  };\n\n  Object.defineProperty(StateNode.prototype, \"initialStateNodes\", {\n    get: function () {\n      var _this = this;\n\n      if (isLeafNode(this)) {\n        return [this];\n      } // Case when state node is compound but no initial state is defined\n\n\n      if (this.type === 'compound' && !this.initial) {\n        if (!IS_PRODUCTION) {\n          warn(false, \"Compound state node '\" + this.id + \"' has no initial state.\");\n        }\n\n        return [this];\n      }\n\n      var initialStateNodePaths = toStatePaths(this.initialStateValue);\n      return flatten(initialStateNodePaths.map(function (initialPath) {\n        return _this.getFromRelativePath(initialPath);\n      }));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Retrieves state nodes from a relative path to this state node.\r\n   *\r\n   * @param relativePath The relative path from this state node\r\n   * @param historyValue\r\n   */\n\n  StateNode.prototype.getFromRelativePath = function (relativePath) {\n    if (!relativePath.length) {\n      return [this];\n    }\n\n    var _a = __read(relativePath),\n        stateKey = _a[0],\n        childStatePath = _a.slice(1);\n\n    if (!this.states) {\n      throw new Error(\"Cannot retrieve subPath '\" + stateKey + \"' from node with no states\");\n    }\n\n    var childStateNode = this.getStateNode(stateKey);\n\n    if (childStateNode.type === 'history') {\n      return childStateNode.resolveHistory();\n    }\n\n    if (!this.states[stateKey]) {\n      throw new Error(\"Child state '\" + stateKey + \"' does not exist on '\" + this.id + \"'\");\n    }\n\n    return this.states[stateKey].getFromRelativePath(childStatePath);\n  };\n\n  StateNode.prototype.historyValue = function (relativeStateValue) {\n    if (!keys(this.states).length) {\n      return undefined;\n    }\n\n    return {\n      current: relativeStateValue || this.initialStateValue,\n      states: mapFilterValues(this.states, function (stateNode, key) {\n        if (!relativeStateValue) {\n          return stateNode.historyValue();\n        }\n\n        var subStateValue = isString(relativeStateValue) ? undefined : relativeStateValue[key];\n        return stateNode.historyValue(subStateValue || stateNode.initialStateValue);\n      }, function (stateNode) {\n        return !stateNode.history;\n      })\n    };\n  };\n  /**\r\n   * Resolves to the historical value(s) of the parent state node,\r\n   * represented by state nodes.\r\n   *\r\n   * @param historyValue\r\n   */\n\n\n  StateNode.prototype.resolveHistory = function (historyValue) {\n    var _this = this;\n\n    if (this.type !== 'history') {\n      return [this];\n    }\n\n    var parent = this.parent;\n\n    if (!historyValue) {\n      var historyTarget = this.target;\n      return historyTarget ? flatten(toStatePaths(historyTarget).map(function (relativeChildPath) {\n        return parent.getFromRelativePath(relativeChildPath);\n      })) : parent.initialStateNodes;\n    }\n\n    var subHistoryValue = nestedPath(parent.path, 'states')(historyValue).current;\n\n    if (isString(subHistoryValue)) {\n      return [parent.getStateNode(subHistoryValue)];\n    }\n\n    return flatten(toStatePaths(subHistoryValue).map(function (subStatePath) {\n      return _this.history === 'deep' ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];\n    }));\n  };\n\n  Object.defineProperty(StateNode.prototype, \"stateIds\", {\n    /**\r\n     * All the state node IDs of this state node and its descendant state nodes.\r\n     */\n    get: function () {\n      var _this = this;\n\n      var childStateIds = flatten(keys(this.states).map(function (stateKey) {\n        return _this.states[stateKey].stateIds;\n      }));\n      return [this.id].concat(childStateIds);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"events\", {\n    /**\r\n     * All the event types accepted by this state node and its descendants.\r\n     */\n    get: function () {\n      var e_7, _a, e_8, _b;\n\n      if (this.__cache.events) {\n        return this.__cache.events;\n      }\n\n      var states = this.states;\n      var events = new Set(this.ownEvents);\n\n      if (states) {\n        try {\n          for (var _c = __values(keys(states)), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var stateId = _d.value;\n            var state = states[stateId];\n\n            if (state.states) {\n              try {\n                for (var _e = (e_8 = void 0, __values(state.events)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                  var event_1 = _f.value;\n                  events.add(\"\" + event_1);\n                }\n              } catch (e_8_1) {\n                e_8 = {\n                  error: e_8_1\n                };\n              } finally {\n                try {\n                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                } finally {\n                  if (e_8) throw e_8.error;\n                }\n              }\n            }\n          }\n        } catch (e_7_1) {\n          e_7 = {\n            error: e_7_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_7) throw e_7.error;\n          }\n        }\n      }\n\n      return this.__cache.events = Array.from(events);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StateNode.prototype, \"ownEvents\", {\n    /**\r\n     * All the events that have transitions directly from this state node.\r\n     *\r\n     * Excludes any inert events.\r\n     */\n    get: function () {\n      var events = new Set(this.transitions.filter(function (transition) {\n        return !(!transition.target && !transition.actions.length && transition.internal);\n      }).map(function (transition) {\n        return transition.eventType;\n      }));\n      return Array.from(events);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  StateNode.prototype.resolveTarget = function (_target) {\n    var _this = this;\n\n    if (_target === undefined) {\n      // an undefined target signals that the state node should not transition from that state when receiving that event\n      return undefined;\n    }\n\n    return _target.map(function (target) {\n      if (!isString(target)) {\n        return target;\n      }\n\n      var isInternalTarget = target[0] === _this.delimiter; // If internal target is defined on machine,\n      // do not include machine key on target\n\n      if (isInternalTarget && !_this.parent) {\n        return _this.getStateNodeByPath(target.slice(1));\n      }\n\n      var resolvedTarget = isInternalTarget ? _this.key + target : target;\n\n      if (_this.parent) {\n        try {\n          var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);\n\n          return targetStateNode;\n        } catch (err) {\n          throw new Error(\"Invalid transition definition for state node '\" + _this.id + \"':\\n\" + err.message);\n        }\n      } else {\n        return _this.getStateNodeByPath(resolvedTarget);\n      }\n    });\n  };\n\n  StateNode.prototype.formatTransition = function (transitionConfig) {\n    var _this = this;\n\n    var normalizedTarget = normalizeTarget(transitionConfig.target);\n    var internal = 'internal' in transitionConfig ? transitionConfig.internal : normalizedTarget ? normalizedTarget.some(function (_target) {\n      return isString(_target) && _target[0] === _this.delimiter;\n    }) : true;\n    var guards = this.machine.options.guards;\n    var target = this.resolveTarget(normalizedTarget);\n    return __assign(__assign({}, transitionConfig), {\n      actions: toActionObjects(toArray(transitionConfig.actions)),\n      cond: toGuard(transitionConfig.cond, guards),\n      target: target,\n      source: this,\n      internal: internal,\n      eventType: transitionConfig.event\n    });\n  };\n\n  StateNode.prototype.formatTransitions = function () {\n    var e_9, _a;\n\n    var _this = this;\n\n    var onConfig;\n\n    if (!this.config.on) {\n      onConfig = [];\n    } else if (Array.isArray(this.config.on)) {\n      onConfig = this.config.on;\n    } else {\n      var _b = this.config.on,\n          _c = WILDCARD,\n          _d = _b[_c],\n          wildcardConfigs = _d === void 0 ? [] : _d,\n          strictOnConfigs_1 = __rest(_b, [typeof _c === \"symbol\" ? _c : _c + \"\"]);\n\n      onConfig = flatten(keys(strictOnConfigs_1).map(function (key) {\n        var arrayified = toTransitionConfigArray(key, strictOnConfigs_1[key]);\n\n        if (!IS_PRODUCTION) {\n          validateArrayifiedTransitions(_this, key, arrayified);\n        }\n\n        return arrayified;\n      }).concat(toTransitionConfigArray(WILDCARD, wildcardConfigs)));\n    }\n\n    var doneConfig = this.config.onDone ? toTransitionConfigArray(String(done(this.id)), this.config.onDone) : [];\n    var invokeConfig = flatten(this.invoke.map(function (invokeDef) {\n      var settleTransitions = [];\n\n      if (invokeDef.onDone) {\n        settleTransitions.push.apply(settleTransitions, __spread(toTransitionConfigArray(String(doneInvoke(invokeDef.id)), invokeDef.onDone)));\n      }\n\n      if (invokeDef.onError) {\n        settleTransitions.push.apply(settleTransitions, __spread(toTransitionConfigArray(String(error(invokeDef.id)), invokeDef.onError)));\n      }\n\n      return settleTransitions;\n    }));\n    var delayedTransitions = this.after;\n    var formattedTransitions = flatten(__spread(doneConfig, invokeConfig, onConfig).map(function (transitionConfig) {\n      return toArray(transitionConfig).map(function (transition) {\n        return _this.formatTransition(transition);\n      });\n    }));\n\n    try {\n      for (var delayedTransitions_1 = __values(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {\n        var delayedTransition = delayedTransitions_1_1.value;\n        formattedTransitions.push(delayedTransition);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_a = delayedTransitions_1.return)) _a.call(delayedTransitions_1);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n\n    return formattedTransitions;\n  };\n\n  return StateNode;\n}();\n\nexport { StateNode };"]},"metadata":{},"sourceType":"module"}